var vt=Object.defineProperty;var yt=(f,p,t)=>p in f?vt(f,p,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[p]=t;var x=(f,p,t)=>yt(f,typeof p!="symbol"?p+"":p,t);import{l as I,j as u,m as Z,k as ot,I as U,B as _,e as rt,q as st,C as xt,r as jt,u as Pt,P as Ot,t as It,i as Et}from"./ui-D2YqbPcu.js";import{a as O,f as Ct}from"./vendor-BhvhDhpY.js";import{c as A,u as Nt,a as wt}from"./useShips-RXMfKXLW.js";import{u as Bt}from"./useEngineeringStats-BBMilB8n.js";import{c as K,a as z}from"./scoring-AiKeAj3b.js";import{S as At,r as nt}from"./SimulationResults-DawwZDmL.js";import{S as at}from"./ShipDisplay-ApR9I5gC.js";import{S as kt}from"./ShipSelector-BxvrfkTU.js";import{G as Tt}from"./GearSlot-BtS1uLEJ.js";import"./useStorage-6AZ-_ceW.js";import"./firebaseStorage-B0eyI6ev.js";import"./GearPieceDisplay-BCww8SQc.js";import"./StatDisplay-zLjdPrVG.js";var B=(f=>(f.TwoPass="twoPass",f.SetFirst="setFirst",f.BeamSearch="beamSearch",f.Genetic="genetic",f.BruteForce="bruteForce",f))(B||{});const it={twoPass:{name:"Two-Pass Algorithm",description:"Fast algorithm that first optimizes stats, then looks for set opportunities"},setFirst:{name:"Set-First Approach",description:"Prioritizes completing gear sets before individual stat optimization"},beamSearch:{name:"Beam Search",description:"Balanced approach keeping multiple possible configurations in consideration"},genetic:{name:"Genetic Algorithm",description:"Evolution-inspired approach for finding optimal gear combinations"},bruteForce:{name:"Brute Force",description:"Tries every possible combination to find the absolute best gear setup (may crash browser)"}};class M{constructor(){x(this,"progressCallback");x(this,"totalOperations",0);x(this,"currentOperation",0);x(this,"PROGRESS_UPDATE_INTERVAL",5e4)}filterInventory(p,t,s=!1){return s?p.filter(i=>!i.shipId||i.shipId===t):p}setProgressCallback(p){this.progressCallback=p}updateProgress(){if(this.progressCallback&&this.totalOperations>0){const p=Math.min(this.currentOperation,this.totalOperations),t=Math.round(p/this.totalOperations*100);this.progressCallback({current:p,total:this.totalOperations,percentage:t})}}initializeProgress(p){this.totalOperations=p,this.currentOperation=0,this.updateProgress()}incrementProgress(){this.currentOperation++,this.updateProgress()}completeProgress(){this.progressCallback&&(this.currentOperation=this.totalOperations,this.progressCallback({current:this.totalOperations,total:this.totalOperations,percentage:100}))}}class qt extends M{constructor(){super(...arguments);x(this,"name","Beam Search");x(this,"description","Balanced approach keeping multiple possible configurations in consideration");x(this,"BEAM_WIDTH",10)}async findOptimalGear(t,s,i,e,a,o,c){const l=this.filterInventory(i,t.id,c);let h=0;Object.keys(I).forEach(r=>{const n=r,g=l.filter(S=>S.slot===n);h+=g.length*this.BEAM_WIDTH}),this.initializeProgress(h);let d=[{equipment:{},score:0}];for(const[r]of Object.entries(I)){const n=r;d=await this.processSlot(n,d,l,t,s,e,a,o)}this.completeProgress();const m=d[0];return Object.entries(m.equipment).filter(r=>r[1]!==void 0).map(([r,n])=>({slotName:r,gearId:n,score:m.score}))}async processSlot(t,s,i,e,a,o,c,l){const h=[],d=i.filter(r=>r.slot===t&&!Object.values(s[0].equipment).includes(r.id));for(const r of s)for(const n of d){const g={...r.equipment,[t]:n.id},S=A(e.baseStats,g,o,e.refits,e.implants,c(e.type)),j=this.calculateConfigurationScore(S.final,a,g,o,l);h.push({equipment:g,score:j}),this.incrementProgress()}const m=h.sort((r,n)=>n.score-r.score).slice(0,this.BEAM_WIDTH);return await new Promise(r=>setTimeout(r,0)),m}calculateConfigurationScore(t,s,i,e,a){const o={};return Object.values(i).forEach(l=>{if(!l)return;const h=e(l);h!=null&&h.setBonus&&(o[h.setBonus]=(o[h.setBonus]||0)+1)}),K(t,s,a,o)}}class Gt extends M{constructor(){super(...arguments);x(this,"name","Two-Pass Algorithm");x(this,"description","Fast algorithm that first optimizes stats, then looks for set opportunities")}async findOptimalGear(t,s,i,e,a,o,c){const l=this.filterInventory(i,t.id,c),h=Object.keys(I).length*l.length+l.filter(r=>r.setBonus).length;this.initializeProgress(h);const d=await this.firstPass(t,s,l,e,a,o),m=await this.secondPass(t,s,l,d,e,a,o);return this.completeProgress(),Object.entries(m).filter(r=>r[1]!==void 0).map(([r,n])=>({slotName:r,gearId:n,score:0}))}async firstPass(t,s,i,e,a,o){const c={};return Object.entries(I).forEach(([l,h])=>{const d=l;let m=-1/0,r;i.filter(n=>n.slot===d).forEach(n=>{const g={...c,[d]:n.id},S=A(t.baseStats,g,e,t.refits,t.implants,a(t.type)),j=this.calculateStatScore(S.final,s,o);j>m&&(m=j,r=n.id),this.incrementProgress()}),r&&(c[d]=r)}),c}async secondPass(t,s,i,e,a,o,c){const l=this.countSets(e,a);return this.findPotentialSets(i,e,a).forEach(({setName:d,pieces:m})=>{if(l[d]===1){const r=this.evaluateEquipment(t,e,s,a,o,c);m.forEach(n=>{const g={...e};g[n.slot]=n.id,this.evaluateEquipment(t,g,s,a,o,c)>r&&(e[n.slot]=n.id),this.incrementProgress()})}}),e}countSets(t,s){const i={};return Object.values(t).forEach(e=>{if(!e)return;const a=s(e);a!=null&&a.setBonus&&(i[a.setBonus]=(i[a.setBonus]||0)+1)}),i}findPotentialSets(t,s,i){const e={};return t.forEach(a=>{a.setBonus&&(e[a.setBonus]||(e[a.setBonus]=[]),e[a.setBonus].push(a))}),Object.entries(e).map(([a,o])=>({setName:a,pieces:o})).filter(({setName:a})=>Object.values(s).filter(c=>{const l=c?i(c):void 0;return(l==null?void 0:l.setBonus)===a}).length===1)}calculateStatScore(t,s,i,e){return K(t,s,i,e)}evaluateEquipment(t,s,i,e,a,o){return z(t,s,i,e,a,o)}}class Mt extends M{constructor(){super(...arguments);x(this,"name","Genetic Algorithm");x(this,"description","Evolution-inspired approach for finding optimal gear combinations");x(this,"POPULATION_SIZE",1e3);x(this,"GENERATIONS",30);x(this,"MUTATION_RATE",.1);x(this,"ELITE_SIZE",5)}async findOptimalGear(t,s,i,e,a,o,c){const l=this.filterInventory(i,t.id,c),h=this.POPULATION_SIZE*this.GENERATIONS;this.initializeProgress(h);let d=this.initializePopulation(l);d=this.evaluatePopulation(d,t,s,e,a,o);for(let r=0;r<this.GENERATIONS;r++){const n=[];for(n.push(...d.slice(0,this.ELITE_SIZE));n.length<this.POPULATION_SIZE;){const g=this.selectParent(d),S=this.selectParent(d),j=this.crossover(g,S);this.mutate(j,l),n.push(j),this.incrementProgress()}d=this.evaluatePopulation(n,t,s,e,a,o),await new Promise(g=>setTimeout(g,0))}this.completeProgress();const m=d[0];return Object.entries(m.equipment).filter(r=>r[1]!==void 0).map(([r,n])=>({slotName:r,gearId:n,score:m.fitness}))}initializePopulation(t){const s=[];for(let i=0;i<this.POPULATION_SIZE;i++){const e={};Object.keys(I).forEach(a=>{const o=a,c=t.filter(l=>l.slot===o);if(c.length>0){const l=c[Math.floor(Math.random()*c.length)];e[o]=l.id}}),s.push({equipment:e,fitness:0})}return s}evaluatePopulation(t,s,i,e,a,o){return t.map(c=>({...c,fitness:this.calculateFitness(c.equipment,s,i,e,a,o)})).sort((c,l)=>l.fitness-c.fitness)}calculateFitness(t,s,i,e,a,o){return z(s,t,i,e,a,o)}selectParent(t){return Array(3).fill(null).map(()=>t[Math.floor(Math.random()*t.length)]).reduce((e,a)=>a.fitness>e.fitness?a:e)}crossover(t,s){const i={};return Object.keys(I).forEach(e=>{const a=e;i[a]=Math.random()<.5?t.equipment[a]:s.equipment[a]}),{equipment:i,fitness:0}}mutate(t,s){Object.keys(I).forEach(i=>{const e=i;if(Math.random()<this.MUTATION_RATE){const a=s.filter(o=>o.slot===e);if(a.length>0){const o=a[Math.floor(Math.random()*a.length)];t.equipment[e]=o.id}}})}}class Lt extends M{constructor(){super(...arguments);x(this,"name","Set-First Approach");x(this,"description","Prioritizes completing gear sets before individual stat optimization")}async findOptimalGear(t,s,i,e,a,o,c){const l=this.filterInventory(i,t.id,c),h=this.groupInventoryBySets(l,t,s,e,a),d=h.length*l.length+Object.keys(I).length;this.initializeProgress(d);const m={},r=new Set;for(const n of h)(await this.findBestSetCombination(n.pieces,r,t,s,m,e,a,o)).forEach(S=>{m[S.slot]=S.id,r.add(S.slot)}),this.incrementProgress();return await this.fillRemainingSlots(m,r,l,t,s,e,a,o),this.completeProgress(),Object.entries(m).filter(n=>n[1]!==void 0).map(([n,g])=>({slotName:n,gearId:g,score:0}))}groupInventoryBySets(t,s,i,e,a){const o={};return t.forEach(c=>{c.setBonus&&(o[c.setBonus]||(o[c.setBonus]=[]),o[c.setBonus].push(c))}),Object.entries(o).map(([c,l])=>{const h=this.evaluateSetPotential(l,s,i,e,a);return{setName:c,pieces:l,score:h}}).filter(c=>c.pieces.length>=2).sort((c,l)=>l.score-c.score)}evaluateSetPotential(t,s,i,e,a){const o=new Set(t.map(l=>l.slot)),c={};return o.forEach(l=>{const h=t.filter(d=>d.slot===l).reduce((d,m)=>{const r=A(s.baseStats,{...c,[l]:m.id},e,s.refits,s.implants,a(s.type)),n=this.calculateStatScore(r.final,i);return!d||n>d.score?{piece:m,score:n}:d},null);h&&(c[l]=h.piece.id)}),z(s,c,i,e,a)}findBestSetCombination(t,s,i,e,a,o,c,l){if(t.map(r=>r.slot).filter(r=>!s.has(r)).length<2)return[];const d=[];let m=-1/0;for(let r=0;r<t.length;r++)for(let n=r+1;n<t.length;n++){const g=t[r],S=t[n];if(g.slot===S.slot||s.has(g.slot)||s.has(S.slot))continue;const j={...a,[g.slot]:g.id,[S.slot]:S.id},N=A(i.baseStats,j,o,i.refits,i.implants,c(i.type)),w=this.calculateStatScore(N.final,e,l)*1.15;w>m&&(m=w,d.length=0,d.push(g,S))}return d}async fillRemainingSlots(t,s,i,e,a,o,c,l){for(const h of Object.keys(I)){const d=h;if(s.has(d)){this.incrementProgress();continue}let m=-1/0,r;i.filter(n=>n.slot===d).forEach(n=>{const g={...t,[d]:n.id},S=A(e.baseStats,g,o,e.refits,e.implants,c(e.type)),j=this.calculateStatScore(S.final,a,l);j>m&&(m=j,r=n.id)}),r&&(t[d]=r,s.add(d)),this.incrementProgress()}}calculateStatScore(t,s,i,e){return K(t,s,i,e)}}class Ft extends M{constructor(){super(...arguments);x(this,"name","Brute Force");x(this,"description","Tries every possible combination to find the absolute best gear setup");x(this,"scoreCache",new Map);x(this,"BATCH_SIZE",5e4)}async findOptimalGear(t,s,i,e,a,o,c){const l=this.filterInventory(i,t.id,c);this.scoreCache.clear();const h=this.groupAndFilterInventory(l,o);this.initializeProgress(this.calculateTotalCombinations(h));const d=await this.findBestConfiguration(t,s,h,{},this.getOptimizedSlotOrder(h),e,a,o);return Object.entries(d.equipment).filter(m=>m[1]!==void 0).map(([m,r])=>({slotName:m,gearId:r,score:d.score}))}getOptimizedSlotOrder(t){return Object.entries(t).sort(([,s],[,i])=>s.length-i.length).map(([s])=>s)}calculateTotalCombinations(t){return Object.values(t).reduce((s,i)=>s*i.length,1)}groupAndFilterInventory(t,s){const i={};return Object.keys(I).forEach(e=>{i[e]=[]}),t.forEach(e=>{s&&!this.isGearRelevantForRole(e,s)||i[e.slot].push(e)}),i}isGearRelevantForRole(t,s){const e={Attacker:["attack","crit","critDamage"],Defender:["hp","defence"],Debuffer:["hacking","attack","crit","critDamage"],Supporter:["hp","healModifier","crit","critDamage"],SupporterBuffer:["speed","hp","defence"]}[s]||[],a=t.subStats.map(o=>o.name);return a.push(t.mainStat.name),e.some(o=>a.includes(o))}getCacheKey(t){return JSON.stringify(t)}findBestConfiguration(t,s,i,e,a,o,c,l){return new Promise(h=>{let d=0,m={equipment:{},score:-1/0};const r=()=>{const n=(S,j)=>{if(j.length===0){this.incrementProgress(),d++;const E=this.getCacheKey(S);if(this.scoreCache.has(E)){const T=this.scoreCache.get(E);return T>m.score&&(m={equipment:{...S},score:T}),!1}const C=z(t,S,s,o,c,l);return this.scoreCache.set(E,C),C>m.score&&(m={equipment:{...S},score:C}),!1}const[N,...w]=j,L=i[N];for(const E of L){if(Object.values(S).includes(E.id))continue;const C={...S,[N]:E.id};if(n(C,w))return!0;if(d>=this.BATCH_SIZE)return d=0,!0}return n(S,w)};n(e,a)&&this.currentOperation<this.totalOperations?setTimeout(r,0):h(m)};r()})}}const _t={[B.BeamSearch]:new qt,[B.TwoPass]:new Gt,[B.Genetic]:new Mt,[B.SetFirst]:new Lt,[B.BruteForce]:new Ft};function zt(f){return _t[f]}const W=["attack","defence","hp","speed","crit","critDamage","healModifier","hacking","security"],Rt=({onAdd:f,existingPriorities:p,hideWeight:t,hideMaxLimit:s,hideMinLimit:i})=>{const[e,a]=O.useState(W[0]),[o,c]=O.useState(""),[l,h]=O.useState(""),[d,m]=O.useState(1),r=n=>{n.preventDefault(),f({stat:e,maxLimit:s?void 0:o?Number(o):void 0,minLimit:i?void 0:l?Number(l):void 0,weight:t?1:d}),c(""),h(""),t||m(p.length>0?p.length+1:1),a(W[0])};return u.jsxs("form",{onSubmit:r,className:"space-y-4 bg-dark p-4",role:"form",children:[u.jsx("div",{className:"space-y-2",children:u.jsx(Z,{label:"Stat",value:e,onChange:n=>a(n),options:W.map(n=>({value:n,label:ot[n].label}))})}),u.jsxs("div",{className:"space-y-2 grid grid-cols-2 gap-4 items-end",children:[!i&&u.jsx(U,{label:"Min Limit (Optional)",type:"number",value:l,onChange:n=>h(n.target.value),placeholder:"min value"}),!s&&u.jsx(U,{label:"Max Limit (Optional)",type:"number",value:o,onChange:n=>c(n.target.value),placeholder:"max value"})]}),!t&&u.jsx(U,{label:"Weight",type:"number",value:d,onChange:n=>m(Number(n.target.value)),placeholder:"Enter weight",className:"mt-4"}),u.jsx(_,{"aria-label":"Add priority",type:"submit",variant:"secondary",fullWidth:!0,children:"Add Priority"})]})},Dt=({selectedShip:f,selectedShipRole:p,selectedAlgorithm:t,priorities:s,ignoreEquipped:i,showSecondaryRequirements:e,onShipSelect:a,onRoleSelect:o,onAlgorithmSelect:c,onAddPriority:l,onRemovePriority:h,onFindOptimalGear:d,onIgnoreEquippedChange:m,onToggleSecondaryRequirements:r})=>u.jsxs("div",{className:"space-y-4",children:[u.jsx("h3",{className:"text-xl font-bold ",children:"Settings"}),u.jsx(kt,{onSelect:a,selected:f}),u.jsxs("div",{className:"p-4 bg-dark space-y-2",children:[u.jsx("span",{className:" text-sm",children:"Predefined Strategies"}),u.jsx(Z,{"data-testid":"role-select",options:Object.values(rt).map(n=>({value:n.name,label:`${n.name} (${n.description})`})),value:p||"",onChange:n=>o(n),noDefaultSelection:!0,defaultOption:"Manual"})]}),p&&u.jsxs("div",{className:"p-4 bg-dark",children:[u.jsx(st,{label:"Add secondary requirements",checked:e,onChange:r}),u.jsx("p",{className:"text-sm text-gray-400 mt-1",children:"Add additional minimum/maximum stat requirements to the predefined role. For example higher hacking, speed targets, cap crit going over 100%. These are soft capped and will penalize the score relatively if not met."})]}),(p===null||p===""||e)&&u.jsx(Rt,{onAdd:l,existingPriorities:s,hideWeight:e}),s.length>0&&u.jsxs("div",{className:"bg-dark p-4 space-y-2 ",children:[u.jsx("h3",{className:"text-lg font-semibold",children:"Priority List"}),s.map((n,g)=>u.jsxs("div",{className:"flex items-center",children:[u.jsxs("span",{children:[ot[n.stat].label," (",n.minLimit?`Min: ${n.minLimit}`:"",n.minLimit&&n.maxLimit?", ":"",n.maxLimit?` Max: ${n.maxLimit}`:"",n.weight!==1?` (Weight: ${n.weight})`:"",") "]}),u.jsx(_,{"aria-label":"Remove priority",variant:"danger",size:"sm",onClick:()=>h(g),className:"ml-auto",children:u.jsx(xt,{})})]},g))]}),u.jsxs("div",{className:"space-y-2 p-4 bg-dark",children:[u.jsx("span",{className:" text-sm",children:"Algorithm"}),u.jsx(Z,{"data-testid":"algorithm-select",options:Object.entries(it).map(([n,{name:g}])=>({value:n,label:g})),value:t,onChange:n=>c(n)}),u.jsx("p",{className:"text-sm text-gray-400",children:it[t].description})]}),u.jsxs("div",{className:"p-4 bg-dark",children:[u.jsx(st,{label:"Ignore currently equipped gear",checked:i,onChange:n=>m(n)}),u.jsx("p",{className:"text-sm text-gray-400 mt-1",children:"When checked, the algorithm will ignore gear that is currently equipped on other ships"})]}),u.jsx(_,{"aria-label":"Find optimal gear",variant:"primary",onClick:d,disabled:!f||(p===""||p===null)&&s.length===0,fullWidth:!0,children:"Find Optimal Gear"})]}),Ht=({suggestions:f,getGearPiece:p,hoveredGear:t,onHover:s,onEquip:i})=>{const e=a=>f.find(o=>o.slotName===a);return u.jsxs("div",{className:"bg-dark-lighter py-4 md:pt-0",children:[u.jsx("div",{className:"flex justify-between items-center mb-4",children:u.jsx("h3",{className:"text-xl font-semibold ",children:"Suggested Gear"})}),u.jsx("div",{className:"grid grid-cols-3 gap-2 bg-dark p-4",children:jt.map(a=>{const o=e(a);return u.jsx("div",{className:"flex items-center justify-center",children:u.jsx(Tt,{slotKey:a,gear:o?p(o.gearId):void 0,hoveredGear:t,onHover:s})},a)})}),u.jsx("div",{className:"flex justify-end pt-4",children:u.jsx(_,{"aria-label":"Equip all suggestions",variant:"primary",onClick:i,children:"Equip All Suggestions"})})]})},ae=()=>{const{getGearPiece:f,inventory:p,saveInventory:t}=Nt(),{getShipById:s,ships:i,handleEquipMultipleGear:e}=wt(),{addNotification:a}=Pt(),[o,c]=O.useState(""),[l,h]=O.useState(null),[d,m]=O.useState([]),[r,n]=O.useState([]),[g,S]=O.useState(null),{getEngineeringStatsForShipType:j}=Bt(),[N,w]=O.useState(B.Genetic),[L,E]=O.useState(null),[C,T]=O.useState(null),[F,R]=O.useState(null),[$,lt]=O.useState(!0),[ct,D]=O.useState(!1),[ut,dt]=O.useState(null),v=s(o),[mt,Y]=O.useState(!1),[V]=Ct();O.useEffect(()=>{const y=V.get("shipId");if(y){const P=s(y);P&&(c(y),h(rt[P.type].name))}},[V,s]);const ht=y=>{m([...d,y])},pt=y=>{m(d.filter((P,b)=>b!==y))},ft=async()=>{if(!v)return;R(null),n([]);const y=zt(N);y.setProgressCallback(R);const P=p.filter(G=>{if(G.shipId){const et=i.find(bt=>bt.id===G.shipId);return G.shipId===v.id||et&&!et.equipmentLocked}return!0}),b=await Promise.resolve(y.findOptimalGear(v,d,P,f,j,l||void 0,$)),k=X(),q=J(b);k&&q&&(E(nt(k.final,l)),T(nt(q.final,l))),n(b)},J=y=>{if(!v)return null;const P={...v.equipment};return y.forEach(b=>{P[b.slotName]=b.gearId}),A(v.baseStats,P,f,v.refits,v.implants,j(v.type))},gt=()=>{if(!v)return;const y=r.map(P=>{const b=f(P.gearId);if(b!=null&&b.shipId&&b.shipId!==v.id){const k=s(b.shipId);if(k)return{fromShip:k.name,slot:I[P.slotName].label,toShip:v.name}}return null}).filter(P=>P!==null);y.length>0?(D(!0),dt(u.jsxs("div",{className:"space-y-2 ",children:[u.jsx("p",{children:"The following gear will be moved:"}),u.jsx("ul",{className:"list-disc pl-4 space-y-1",children:y.map((P,b)=>u.jsxs("li",{children:[P.slot," from"," ",u.jsx("span",{className:"font-semibold",children:P.fromShip})]},b))}),u.jsx("p",{className:"mt-4",children:"Do you want to continue?"})]}))):Q()},Q=()=>{if(!v)return;const y=r.map(b=>({slot:b.slotName,gearId:b.gearId}));e(v.id,y);const P=p.map(b=>y.find(q=>q.gearId===b.id)?{...b,shipId:v.id}:b.shipId===v.id&&!y.some(G=>G.gearId===b.id)?{...b,shipId:""}:b);t(P),a("success","Suggested gear equipped successfully"),n([]),R(null),D(!1)},X=()=>v?A(v.baseStats,v.equipment,f,v.refits,v.implants,j(v.type)):null,St=y=>{h(y),Y(!1),E(null),T(null)},H=X(),tt=J(r);return u.jsxs(Ot,{title:"Autogear",description:"Find the best gear for your ship.",children:[u.jsxs("div",{className:"md:grid md:grid-cols-2 gap-4",children:[u.jsx(Dt,{selectedShip:v||null,selectedShipRole:l,selectedAlgorithm:N,priorities:d,ignoreEquipped:$,onIgnoreEquippedChange:lt,onShipSelect:y=>c(y.id),onRoleSelect:St,onAlgorithmSelect:w,onAddPriority:ht,onRemovePriority:pt,onFindOptimalGear:ft,showSecondaryRequirements:mt,onToggleSecondaryRequirements:Y}),r.length>0&&u.jsx(Ht,{suggestions:r,getGearPiece:f,hoveredGear:g,onHover:S,onEquip:gt}),F&&u.jsx("div",{className:"col-span-2 p-4 bg-dark",children:u.jsx(It,{current:F.current,total:F.total,percentage:F.percentage})})]}),L&&C&&r.length>0&&u.jsx(At,{currentSimulation:L,suggestedSimulation:C,role:l}),H&&tt&&r.length>0&&u.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4 ",children:[u.jsx(at,{stats:H.final,title:"Current Stats",className:"p-4"}),u.jsx(at,{stats:tt.final,comparisonStats:H.final,title:"Stats with Suggested Gear",className:"p-4"})]}),u.jsx(Et,{isOpen:ct,onClose:()=>D(!1),onConfirm:Q,title:"Move Gear",message:ut,confirmLabel:"Move",cancelLabel:"Cancel"})]})};export{ae as AutogearPage,ae as default};
